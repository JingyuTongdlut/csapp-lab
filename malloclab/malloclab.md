# malloclab
本次lab需要我们事先一个显示的动态内存分配器，要实现4个函数，malloc,free,realloc以及calloc函数。  

ps:之前几个实验都是在wsl上跑的，除了需要更改32位以外，别的倒没什么问题，但是这次实验的评分是和时间相关的，我发现wsl里跑的太慢了。。。所以改成笔记本Ubuntu跑了。

存储器需要两个方面技术：空闲块组织方式，以及查找空闲块的方法。  
空闲块组织方式有：  
* 隐式空闲链表
* 显式空闲链表
* 分离空闲链表  

查找空闲块的方式有：  
* 首次适配
* 最佳适配
* 下一次适配

在memlib.c模拟了内存系统，提供了如下几个方法：
* `void *mem_sbrk(int incr)`：让堆扩展 incr 个字节，并返回新分配的地址的头指针
* `void *mem_heap_lo(void)`：返回指向堆的第一个字节的指针
* `void *mem_heap_hi(void)`：返回指向堆的最后一个字节的指针
* `size_t mem_heapsize(void)`：返回当前的堆大小
* `size_t mem_pagesize(void)`：返回系统的 page size

## 隐式空闲链表+首次适配+realloc
我们首先选用最简单的隐式空闲链表+首次适配+realloc方式。

首先采用csapp书中最简单的方式，采用隐式空闲链表组织空闲块，并且在头部和尾部添加了序言块和结尾块，方便添加和释放块。

在空闲块适配上，我们同样才用了最简单的首次适配策略，由头到尾遍历的第一个符合大小的空闲块会被采用。这种方式显然不是最佳，会在头部形成大量碎片。


这种方式的实验结果如下：  
![malloc1](./asserts/malloc1.png)

可以看到，因为选取的方案特别简单，所以得分也特别低。。。代码可以在[mem-1](./malloclab-handout/mm-1.c)

## 显示空闲链表+首次适配+realloc
对于隐式空闲链表，要找到空闲链表，是O(l)时间，其中l为所有块的长度。如果我们将其改进为显示空闲链表，也就是再添加一个双向链表组合空闲链表队列，那么只需要O(e)时间，其中e为空闲块长度。

具体来说，我们采用的显示空闲链表策略为LIFO，也就是新释放的空闲块会被存放到队列头，获取空闲块的时候从队列头开始搜索。

经过这种改善，我们的实验结果如下：  
![malloc2](./asserts/malloc2.png)

可以看到分数比隐式的要提高了很多，这和我们理论分析也是一致的。代码可以在[mem-2](./malloclab-handout/mm-2.c)

## 分离空闲链表+首次适配(最佳)+realloc
显示空闲链表的时间复杂度和空闲块也是成线性的，为了更进一步提高时间，我们可以采用分离空闲链表。分离空闲链表对空闲块进行了更进一步的划分，这样能够进一步缩短找到最佳的匹配块的时间。

分离空闲链表书上介绍了两种方式进行存储：  
* 简单分离存储  
  这种方式链表内大小都是一致的，不需要进行分离，合并等。但是很容易造成外部和内部碎片。
* 分离适配  
  找到最佳适配后，会进行分割，然后将剩余部分插入到合适的位置，这种方式同样能够有效的减少搜索时间，并且，内存利用率更高(有分割，有合并，肯定更高)
综上，因为实验衡量了内存利用率和吞吐率，因此我们选用了更加均衡的分离适配方式，这也是c语言malloc采用方式。

我们最终的实验结果如下：  
![malloc3](./asserts/malloc3.png)

可以看到分数比显示的略有提高，这和我们理论分析也是一致的。代码可以在[mem-3](./malloclab-handout/mm-3.c)

## 总结
这次实验让我对内存适配器的实现有着更加深刻的认识，最后的得分其实还有待改进，如realloc如果前后可以合并，其实不需要想系统申请更多的空间，等。这部分实验做了很久，日后有时间的时候再尝试提高得分。

