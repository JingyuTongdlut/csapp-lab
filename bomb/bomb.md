# 炸弹
这次要求我们通过二进制文件，进行拆除炸弹。汇编基本都不记得了，这篇会参考比较多网上的资料。

## 1.第一关
拿到二进制文件，我们首先反汇编出汇编代码: `objdump -d bomb > bomb.txt`，然后找到phase_1的位置
![bomb_1](/assets/bomb_1.png)

我们可以看到，在phase_1里调用了string_not_euqal函数，其中，把0x402400处的字符串当做第二个参数传入，这里没有给出第一个参数，也就是rdi的值，我们找到调用的地方可以查看到：
![bomb2](/assets/bomb2.png)

只有这里调用了phase_1，此时rdi的值是通过read_line的返回值rax传递的，那么string_not_equal这个就是比较输入和0x402400处的是否相等，然后测试eax进行跳转，或者引爆可以在第一段看到，如果eax是0的话，就会跳转，那么也就不会引爆。

那么重点就是改地址的字符串的值了，通过gdb调试可以找到这个字符串
![bomb3](/assets/bomb3_dqmofs8ev.png)
`Border relations with Canada have never been better.`

输入后，输出如下：
![bomb_4](/assets/bomb_4_p0sqm0eif.png)

## 2.第二关
我们依然采用反汇编方式查看代码，如下：
![bomb_5](/assets/bomb_5_8izp1ypkh.png)

可以看到，程序通过read_six_numbers读入6个数字，然后通过cmpl判断第一个参数是否为1，如果是，改变rbx指向栈的下一个元素，并判断是否为上一个的2倍，不停循环，知道rbp和rbx相等(处理完了)。

因此，我们输入的6个数为`1 2 4 8 16 32`，结果如下：
![bomb6](/assets/bomb6.png)

## 3.第三关
一样，先反汇编：
![bomb7](/assets/bomb7.png)

可以看到有两处bomb，第一处比较的是eax，也就是scanf的返回值，所以不用太在意，但是我们需要根据scanf第一个参数，确定要输入几个数，可以打印出esi的值来确定，这里为%d %d，那么我们需要输入两个参数即可躲过第一个。

接着，会利用cmpl判断第一个参数是不是大于7，大于7也会爆炸，那么我们填入一个小于7的即可，这里填1。
然后，根据一个跳转jmpq(可以用x/x (int*)打印内存信息)，可以看到1对应的第二个参数为0x137，也就是311,`1 311`，结果如下：
![bomb8](/assets/bomb8.png)

## 4.第四关
一样，反汇编，然后看scanf的个数，这题为2：
![bomb9](/assets/bomb9.png)

可以看到一个参数(**p1**)必须小于0xe，然后调用了func4，汇编代码如下：
![bomb10](/assets/bomb10_2ixk6e3ep.png)

根据phase_4的传参，我们可以看出func4的三个参数分别为p1,0,14。然后，根据第一个cmp，第一个参数要小于等于第三个/2才能够退出，根据jge，又得出第一个必须大于等于第三个/2才能退出，那么第一个正好等于第三个/2时，即14/2=7，可以。
所以，我们输入`7 0`，可以得到：
![bomb11](/assets/bomb11.png)

## 5.第五关
一样，先反汇编：
![bomb12](/assets/bomb12.png)

首先判断string_length的答案必须为6，我们知道需要输入一个6位的字符串。接着41-74其实是一个循环，ecx以rax为索引，读取我们输入的6个字符，然后取出低4位，接着以低4位访问0x4024b0处的值，再放到rsp+16中。

在循环外，会将循环字符串和0x40245e处的进行比较，需要相等，才不会爆炸。我们首先查看两个字符串，然后，我们编一个后四位访问等于flvers的字符串即可。
![bomb13](/assets/bomb13.png)
![bomb14](/assets/bomb14.png)

我们可以得到低4位分别是:9 f e 5 6 7，这题只要低4位满足即可，我们以高4位为3，可以得到6个字符为`9?>567`，结果如下：
![bomb15](/assets/bomb15.png)

## 6.第六关
一样，先反汇编，这次代码有点长。。。
![bomb16](/assets/bomb16.png)
![bomb17](/assets/bomb17.png)

首先通过read_six_numbers，读入6个数，并且第一个数要小于等于6，然后我们关注+32到+93这一段是一个循环嵌套，+65到+87是一个被嵌套的循环。这部分判断每个输入的数都要小于6，并且不能重复。

接着，+108到+121这部分，用7减去了这每个数

![bomb18](/assets/bomb18.png)

接下来这半就看不太懂了，毕竟上完计原再也没写过汇编了，基本都忘了，上网查了下这部分大概意思是判断输入的顺序和上图6个链表的大小顺序是不是相等，因此我们输入排序后的顺序即可`4 3 2 1 6 5
![bomb19](/assets/bomb19.png)`。

炸弹拆除！

## 总结
感觉这个实验主要加深汇编以及gdb调试方面的问题，这是第一次接触反汇编，感觉还挺有意思的，最后一个实验比较复杂，要多分析多调试。此外，这个实验似乎每年都在变，所以在网上找到的并不一定跟下载的一样，需要注意。
